{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport class SudokuGeneratorService {\n  constructor() {\n    this.grid = Array.from({\n      length: 9\n    }, () => Array(9).fill(0));\n  }\n  isSafe(row, col, num) {\n    for (let i = 0; i < 9; i++) {\n      if (this.grid[row][i] === num || this.grid[i][col] === num) return false;\n    }\n    const startRow = Math.floor(row / 3) * 3;\n    const startCol = Math.floor(col / 3) * 3;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        if (this.grid[startRow + i][startCol + j] === num) return false;\n      }\n    }\n    return true;\n  }\n  solve(row = 0, col = 0) {\n    if (row === 9) return true;\n    if (col === 9) return this.solve(row + 1, 0);\n    if (this.grid[row][col] !== 0) return this.solve(row, col + 1);\n    let numbers = Array.from({\n      length: 9\n    }, (_, i) => i + 1).sort(() => Math.random() - 0.5);\n    for (let num of numbers) {\n      if (this.isSafe(row, col, num)) {\n        this.grid[row][col] = num;\n        if (this.solve(row, col + 1)) return true;\n        this.grid[row][col] = 0;\n      }\n    }\n    return false;\n  } // Function to check if a number can be placed in a cell\n  isValid(board, row, col, num) {\n    for (let i = 0; i < 9; i++) {\n      if (board[row][i] === num || board[i][col] === num) {\n        return false;\n      }\n    }\n    const startRow = Math.floor(row / 3) * 3;\n    const startCol = Math.floor(col / 3) * 3;\n    for (let i = startRow; i < startRow + 3; i++) {\n      for (let j = startCol; j < startCol + 3; j++) {\n        if (board[i][j] === num) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  printSudoku(grid) {\n    grid.forEach(row => console.log(row.join('')));\n    console.log(grid);\n    return grid;\n  }\n  generateSudoku() {\n    this.grid = Array.from({\n      length: 9\n    }, () => Array(9).fill(0));\n    this.solve();\n    return this.printSudoku(this.grid);\n  }\n  // Count solutions for a given board state\n  countSolutions(board) {\n    let solutionCount = 0;\n    const backtrack = (row, col) => {\n      if (row === 9) {\n        solutionCount += 1;\n        return;\n      }\n      const nextRow = col === 8 ? row + 1 : row;\n      const nextCol = (col + 1) % 9;\n      if (board[row][col] !== 0) {\n        backtrack(nextRow, nextCol);\n      } else {\n        for (let num = 1; num <= 9; num++) {\n          if (this.isValid(board, row, col, num)) {\n            board[row][col] = num;\n            backtrack(nextRow, nextCol);\n            board[row][col] = 0;\n          }\n        }\n      }\n    };\n    backtrack(0, 0);\n    return solutionCount;\n  }\n  generatePuzzleWith25Clues(grid) {\n    const board = grid.map(row => [...row]);\n    // Count how many clues are currently present\n    let clues = 81; // Start with a completely filled grid\n    // Keep removing clues until only 25 remain\n    while (clues > 25) {\n      const row = Math.floor(Math.random() * 9);\n      const col = Math.floor(Math.random() * 9);\n      if (board[row][col] !== 0) {\n        // Only try removing if the cell is not already empty\n        const backup = board[row][col]; // Store the number before removing\n        board[row][col] = 0; // Remove the number\n        // Check if the puzzle still has **only one unique solution**\n        if (this.countSolutions(board) !== 1) {\n          board[row][col] = backup; // Restore the number if multiple solutions exist\n        } else {\n          clues--; // Successfully removed one clue\n        }\n      }\n    }\n\n    return board; // Return the board with exactly 25 clues\n  }\n\n  static {\n    this.ɵfac = function SudokuGeneratorService_Factory(t) {\n      return new (t || SudokuGeneratorService)();\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: SudokuGeneratorService,\n      factory: SudokuGeneratorService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["SudokuGeneratorService","constructor","Array","from","length","fill","isSafe","row","col","num","i","grid","startRow","Math","floor","startCol","j","solve","numbers","_","sort","random","isValid","board","printSudoku","forEach","console","log","join","generateSudoku","countSolutions","solutionCount","backtrack","nextRow","nextCol","generatePuzzleWith25Clues","map","clues","backup","factory","providedIn"],"sourceRoot":"","sources":["D:\\Angular\\Suduku_project\\Frontend\\app\\src\\app\\service\\sudoku-generator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class SudokuGeneratorService {\n  private grid: number[][] = Array.from({ length: 9 }, () => Array(9).fill(0));\n\n  constructor() {}\n  isSafe(row: number, col: number, num: number): boolean {\n    for (let i = 0; i < 9; i++) {\n      if (this.grid[row][i] === num || this.grid[i][col] === num) return false;\n    }\n\n    const startRow = Math.floor(row / 3) * 3;\n    const startCol = Math.floor(col / 3) * 3;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        if (this.grid[startRow + i][startCol + j] === num) return false;\n      }\n    }\n    return true;\n  }\n\n  solve(row = 0, col = 0): boolean {\n    if (row === 9) return true;\n    if (col === 9) return this.solve(row + 1, 0);\n    if (this.grid[row][col] !== 0) return this.solve(row, col + 1);\n\n    let numbers = Array.from({ length: 9 }, (_, i) => i + 1).sort(\n      () => Math.random() - 0.5\n    );\n\n    for (let num of numbers) {\n      if (this.isSafe(row, col, num)) {\n        this.grid[row][col] = num;\n        if (this.solve(row, col + 1)) return true;\n        this.grid[row][col] = 0;\n      }\n    }\n    return false;\n  } // Function to check if a number can be placed in a cell\n  isValid(board: number[][], row: number, col: number, num: number): boolean {\n    for (let i = 0; i < 9; i++) {\n      if (board[row][i] === num || board[i][col] === num) {\n        return false;\n      }\n    }\n\n    const startRow = Math.floor(row / 3) * 3;\n    const startCol = Math.floor(col / 3) * 3;\n    for (let i = startRow; i < startRow + 3; i++) {\n      for (let j = startCol; j < startCol + 3; j++) {\n        if (board[i][j] === num) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  printSudoku(grid: number[][]) {\n    grid.forEach((row) => console.log(row.join('')));\n    console.log(grid);\n    return grid;\n  }\n  generateSudoku() {\n    this.grid = Array.from({ length: 9 }, () => Array(9).fill(0));\n    this.solve();\n\n    return this.printSudoku(this.grid);\n  }\n  // Count solutions for a given board state\n  countSolutions(board: number[][]): number {\n    let solutionCount = 0;\n\n    const backtrack = (row: number, col: number): void => {\n      if (row === 9) {\n        solutionCount += 1;\n        return;\n      }\n      const nextRow = col === 8 ? row + 1 : row;\n      const nextCol = (col + 1) % 9;\n\n      if (board[row][col] !== 0) {\n        backtrack(nextRow, nextCol);\n      } else {\n        for (let num = 1; num <= 9; num++) {\n          if (this.isValid(board, row, col, num)) {\n            board[row][col] = num;\n            backtrack(nextRow, nextCol);\n            board[row][col] = 0;\n          }\n        }\n      }\n    };\n\n    backtrack(0, 0);\n    return solutionCount;\n  }\n  generatePuzzleWith25Clues(grid: any): any[][] {\n    const board = grid.map((row: any) => [...row]);\n    // Count how many clues are currently present\n    let clues = 81; // Start with a completely filled grid\n\n    // Keep removing clues until only 25 remain\n    while (clues > 25) {\n      const row = Math.floor(Math.random() * 9);\n      const col = Math.floor(Math.random() * 9);\n\n      if (board[row][col] !== 0) {\n        // Only try removing if the cell is not already empty\n        const backup = board[row][col]; // Store the number before removing\n        board[row][col] = 0; // Remove the number\n\n        // Check if the puzzle still has **only one unique solution**\n        if (this.countSolutions(board) !== 1) {\n          board[row][col] = backup; // Restore the number if multiple solutions exist\n        } else {\n          clues--; // Successfully removed one clue\n        }\n      }\n    }\n\n    return board; // Return the board with exactly 25 clues\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}